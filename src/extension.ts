// src/extension.ts
import * as vscode from 'vscode';
import { extractPythonBlocks, PythonBlock} from './symbol-extractor';

const CACHE_DIR = '.renpy-pyright';
let cacheDir: vscode.Uri | null = null;
const rebuildQueue = new Map<string, NodeJS.Timeout>();
const fileIndex = new Map<string, IndexedBlock[]>();
const rebuildVersion = new Map<string, number>();
interface IndexedBlock extends PythonBlock {
    pyLineStart: number;
}
function scheduleRebuild(uri: vscode.Uri) {
    const key = uri.toString();

    if (rebuildQueue.has(key)) {
        clearTimeout(rebuildQueue.get(key)!);
    }

    rebuildQueue.set(key, setTimeout(() => {
        rebuildFile(uri);
        rebuildQueue.delete(key);
    }, 250));
}
async function initCacheDir(): Promise<vscode.Uri | null> {
    if (cacheDir) {return cacheDir;}

    const root = vscode.workspace.workspaceFolders?.[0];
    if (!root) {return null;}

    cacheDir = vscode.Uri.joinPath(root.uri, CACHE_DIR);
    await vscode.workspace.fs.createDirectory(cacheDir);
    return cacheDir;
}
async function ensureCacheDir(): Promise<vscode.Uri | null> {
    const root = vscode.workspace.workspaceFolders?.[0];
    if (!root) {return null;}
    const dir = vscode.Uri.joinPath(root.uri, CACHE_DIR);
    await vscode.workspace.fs.createDirectory(dir);
    return dir;
}
function rpyToPyUri(rpy: vscode.Uri, cacheDir: vscode.Uri): vscode.Uri {
    const root = vscode.workspace.workspaceFolders![0].uri;
    const rel = rpy.path.slice(root.path.length + 1);
    return vscode.Uri.joinPath(cacheDir, rel.replace(/\.rpy$/, '.py'));
}
function buildMirror(
    blocks: PythonBlock[],
    rpyUri: vscode.Uri
): { text: string; indexed: IndexedBlock[] } {

    const out: string[] = [];
    const indexed: IndexedBlock[] = [];
    let pyLine = 0;

    out.push(`# Mirror of ${rpyUri.path}`);
    out.push(`# Generated by [ Ren'Py docsup v0.0.4.1]`);
    out.push('');
    pyLine += 3;

    for (const b of blocks) {
        out.push(`# --- block from line ${b.startLine} ---`);
        pyLine++;

        const start = pyLine;
        const lines = b.code.split('\n');
        out.push(...lines);
        pyLine += lines.length;
        out.push('');
        pyLine++;
        indexed.push({ ...b, pyLineStart: start });
    }
    return { text: out.join('\n'), indexed };
}
function mapRpyToPy(pos: vscode.Position, block: IndexedBlock): vscode.Position {
    const entry = block.lineMap.find(e => e.rpyLine === pos.line);
    if (!entry) {return new vscode.Position(block.pyLineStart, 0);}
    return new vscode.Position(
        block.pyLineStart + entry.pyLine,
        Math.max(0, pos.character - entry.rpyColBase)
    );
}

function mapPyToRpy(pos: vscode.Position, block: IndexedBlock): vscode.Position | null {
    const rel = pos.line - block.pyLineStart;
    const entry = block.lineMap.find(e => e.pyLine === rel);
    if (!entry) {return null;}
    return new vscode.Position(
        entry.rpyLine,
        entry.rpyColBase + pos.character
    );
}

async function rebuildFile(rpyUri: vscode.Uri) {
    const key = rpyUri.toString();
    const v = (rebuildVersion.get(key) ?? 0) + 1;
    rebuildVersion.set(key, v);

    const text = Buffer.from(
        await vscode.workspace.fs.readFile(rpyUri)
    ).toString('utf8');

    if (rebuildVersion.get(key) !== v) {return;} // 放弃旧任务

    const blocks = extractPythonBlocks(text);
    const { text: pyText, indexed } = buildMirror(blocks, rpyUri);

    if (rebuildVersion.get(key) !== v) {return;}
    
    if (!cacheDir) {
        console.error("Cache directory is not initialized.");
        return;
    }
    const pyUri = rpyToPyUri(rpyUri, cacheDir);

    await vscode.workspace.fs.createDirectory(pyUri.with({ path: pyUri.path.replace(/\/[^/]+$/, '') }));
    await vscode.workspace.fs.writeFile(pyUri, Buffer.from(pyText, 'utf8'));

    fileIndex.set(rpyUri.toString(), indexed);
}
function findBlockAt(
    blocks: IndexedBlock[],
    line: number
): IndexedBlock | undefined {
    return blocks.find(b =>
        b.lineMap.some(m => m.rpyLine === line)
    );
}
function mapPyToAnyRpy(
    pos: vscode.Position,
    blocks: IndexedBlock[]
): vscode.Position | null {
    for (const b of blocks) {
        const r = mapPyToRpy(pos, b);
        if (r) {return r;}
    }
    return null;
}
async function ensurePyDocument(pyUri: vscode.Uri): Promise<vscode.TextDocument> {
    try {
        return await vscode.workspace.openTextDocument(pyUri);
    } catch (e) {
        console.error('Failed to open mirror py document:', pyUri.toString(), e);
        throw e;
    }
}

export async function activate(ctx: vscode.ExtensionContext) {
    const dir = await initCacheDir();
    if (!dir) {return;}

    // 初始索引
    const files = await vscode.workspace.findFiles('**/*.rpy');
    for (const f of files) {await rebuildFile(f);}

    // hover
    ctx.subscriptions.push(vscode.languages.registerHoverProvider('renpy', {
        async provideHover(doc, pos) {
            const blocks = fileIndex.get(doc.uri.toString());
            if (!blocks) {return null;}

            const block = findBlockAt(blocks, pos.line);
            if (!block) {return null;}

            if (!cacheDir) {
                return null;
            }

            const pyUri = rpyToPyUri(doc.uri, cacheDir);
            await ensurePyDocument(pyUri);
            const pyPos = mapRpyToPy(pos, block);

            const hovers = await vscode.commands.executeCommand<vscode.Hover[]>(
                'vscode.executeHoverProvider',
                pyUri,
                pyPos
            );
            if (!hovers?.length) {return null;}

            const h = hovers[0];
            if (!h.range) {return h;}

            const start = mapPyToRpy(h.range.start, block);
            const end = mapPyToRpy(h.range.end, block);
            if (!start || !end) {return null;}

            return new vscode.Hover(h.contents, new vscode.Range(start, end));
        }
    }));

    // definition
    ctx.subscriptions.push(vscode.languages.registerDefinitionProvider('renpy', {
        async provideDefinition(doc, pos) {
            const blocks = fileIndex.get(doc.uri.toString());
            if (!blocks) {return null;}

            const block = findBlockAt(blocks, pos.line);
            if (!block) {return null;}

            if (!cacheDir) {
                return null;
            }

            const pyUri = rpyToPyUri(doc.uri, cacheDir);
            await ensurePyDocument(pyUri);
            const pyPos = mapRpyToPy(pos, block);

            const defs = await vscode.commands.executeCommand<vscode.Location[]>(
                'vscode.executeDefinitionProvider',
                pyUri,
                pyPos
            );
            if (!defs?.length) {return null;}

            const def = defs[0];
            const rpyPos = mapPyToAnyRpy(def.range.start, blocks);
            if (!rpyPos) {return null;}

            return new vscode.Location(doc.uri, rpyPos);
        }
    }));

    // 增量更新
    ctx.subscriptions.push(
        vscode.workspace.onDidChangeTextDocument(e => {
            if (e.document.languageId === 'renpy') {
                scheduleRebuild(e.document.uri);
            }
        })
    );
    ctx.subscriptions.push(
        vscode.workspace.onDidDeleteFiles(e => {
            for (const f of e.files) {
                fileIndex.delete(f.toString());
            }
        })
    );

    ctx.subscriptions.push(
        vscode.workspace.onDidRenameFiles(e => {
            for (const f of e.files) {
                const oldKey = f.oldUri.toString();
                const data = fileIndex.get(oldKey);
                if (data) {
                    fileIndex.delete(oldKey);
                    fileIndex.set(f.newUri.toString(), data);
                }
            }
        })
    );
}

export function deactivate() {}