// src/extension.ts
import * as vscode from 'vscode';
import * as fs from 'fs';
import { extractPythonBlocks, PythonBlock } from './symbol-extractor';

const CACHE_DIR = '.renpy-pyright';
let cacheDir: vscode.Uri | null = null;

const rebuildQueue = new Map<string, NodeJS.Timeout>();
const fileIndex = new Map<string, IndexedBlock[]>(); // key: rpyUri.toString()
const rebuildVersion = new Map<string, number>();
const DEBOUNCE = 120; // ms

const pyDocCache = new Map<string, vscode.TextDocument>();
const storeIndex = new Map<string, IndexedBlock[]>();

interface IndexedBlock extends PythonBlock {
    pyLineStart: number;
    filePath: string;
}

// schedule rebuild
function scheduleRebuild(uri: vscode.Uri) {
    const key = uri.toString();
    if (rebuildQueue.has(key)) {clearTimeout(rebuildQueue.get(key)!);}
    rebuildQueue.set(key, setTimeout(() => {
        rebuildFile(uri).catch(e => console.error('rebuildFile error', e));
        rebuildQueue.delete(key);
    }, DEBOUNCE));
}

// cache dir
async function getCacheDir(): Promise<vscode.Uri | null> {
    if (cacheDir) {return cacheDir;}
    const root = vscode.workspace.workspaceFolders?.[0];
    if (!root) {return null;}
    cacheDir = vscode.Uri.joinPath(root.uri, CACHE_DIR);
    try {
        await vscode.workspace.fs.createDirectory(cacheDir);
    } catch (e) {
        console.error('Failed to create cache dir:', e);
        return null;
    }
    return cacheDir;
}

// single-mirror path (no store in path)
function rpyToPyUri(rpy: vscode.Uri, cacheDir: vscode.Uri): vscode.Uri {
    const root = vscode.workspace.workspaceFolders![0].uri;
    const rel = rpy.path.slice(root.path.length + 1);
    const pyRel = rel.replace(/\.rpy$/, '.py');
    return vscode.Uri.joinPath(cacheDir, pyRel);
}

function buildMirror(blocks: PythonBlock[], rpyUri: vscode.Uri) {
    const out: string[] = [];
    const indexed: IndexedBlock[] = [];
    let pyLine = 0;

    out.push(`# Mirror of ${rpyUri.path}`);
    out.push(`# Generated by [ Ren'Py docsup v0.0.4.12]`);
    out.push('');
    pyLine += 3;

    for (const b of blocks) {
        out.push(`# --- block from line ${b.startLine} store=${b.store} type=${b.type} ---`);
        pyLine++;

        let lines = b.code.split('\n');

        if (b.type === 'init' || b.type === 'python') {
            const firstNonEmpty = lines.findIndex(l => l.trim() !== '');
            if (firstNonEmpty >= 0) {
                const baseIndent = (lines[firstNonEmpty].match(/^(\s*)/) || ['',''])[1].length;
                lines = lines.map(l => l.startsWith(' '.repeat(baseIndent)) ? l.slice(baseIndent) : l);
            }
        }

        const start = pyLine;
        out.push(...lines);
        pyLine += lines.length;
        out.push('');
        pyLine++;
        indexed.push({ ...b, pyLineStart: start, filePath: rpyUri.fsPath });
    }

    return { text: out.join('\n'), indexed };
}

// map rpy pos -> py pos (best effort)
function mapRpyToPy(pos: vscode.Position, block: IndexedBlock): vscode.Position {
    let entry = block.lineMap.find(e => e.rpyLine === pos.line);
    if (!entry) {
        const rel = pos.line - block.startLine;
        if (rel >= 0 && rel < block.lineMap.length) {entry = block.lineMap[rel];}
        else {entry = block.lineMap[block.lineMap.length - 1];}
    }
    const pyLine = block.pyLineStart + (entry?.pyLine ?? 0);
    const pyCol = Math.max(0, pos.character - (entry?.rpyColBase ?? 0));
    return new vscode.Position(pyLine, pyCol);
}

// map py pos -> rpy pos (exact)
function mapPyToRpy(pos: vscode.Position, block: IndexedBlock): vscode.Position | null {
    const rel = pos.line - block.pyLineStart;
    const entry = block.lineMap.find(e => e.pyLine === rel);
    if (!entry) {return null;}
    return new vscode.Position(entry.rpyLine, Math.max(0, entry.rpyColBase + pos.character));
}

function mapPyToAnyRpy(pos: vscode.Position, blocks: IndexedBlock[]): vscode.Position | null {
    for (const b of blocks) {
        const r = mapPyToRpy(pos, b);
        if (r) {return r;}
    }
    return null;
}

// file order (Ren'Py-like)
function sortRpyFiles(files: vscode.Uri[]): vscode.Uri[] {
    const pathOrder = (uri: vscode.Uri) => {
        const path = uri.fsPath.replace(/\\/g, '/');
        if (path.includes('/renpy/common/')) {return '1' + path;}
        if (path.includes('/game/libs/') && fsExistsSync(path.replace(/[^/]+$/, 'libs.txt'))) {return '2' + path;}
        if (path.includes('/game/')) {return '3' + path;}
        if (path.includes('/game/mods/') && fsExistsSync(path.replace(/[^/]+$/, 'mods.txt'))) {return '4' + path;}
        return '5' + path;
    };
    return [...files].sort((a, b) => pathOrder(a).localeCompare(pathOrder(b)));
}
function fsExistsSync(path: string): boolean { return fs.existsSync(path); }

// store index maintenance
function removeFileFromStoreIndex(filePath: string) {
    for (const [store, arr] of storeIndex.entries()) {
        const filtered = arr.filter(e => e.filePath !== filePath);
        storeIndex.set(store, filtered);
    }
}
function addIndexedToStoreIndex(indexed: IndexedBlock[]) {
    for (const b of indexed) {
        const store = b.store ?? 'store';
        if (!storeIndex.has(store)) {storeIndex.set(store, []);}
        storeIndex.get(store)!.push(b);
    }
}

// doc cache helper
async function ensurePyDocumentCached(pyUri: vscode.Uri) {
    const key = pyUri.toString();
    if (!pyDocCache.has(key)) {
        const doc = await vscode.workspace.openTextDocument(pyUri);
        pyDocCache.set(key, doc);
    }
    return pyDocCache.get(key)!;
}
function invalidatePyDocumentCache(pyUri: vscode.Uri) {
    const key = pyUri.toString();
    if (pyDocCache.has(key)) {pyDocCache.delete(key);}
}

// rebuild single file
async function rebuildFile(rpyUri: vscode.Uri) {
    const key = rpyUri.toString();
    const v = (rebuildVersion.get(key) ?? 0) + 1;
    rebuildVersion.set(key, v);

    const text = Buffer.from(await vscode.workspace.fs.readFile(rpyUri)).toString('utf8');
    if (rebuildVersion.get(key) !== v) {return;}

    const blocks = extractPythonBlocks(text);
    const initBlocks = blocks.filter(b => b.type === 'init').sort((a,b) => (a.priority ?? 0) - (b.priority ?? 0));
    const normalBlocks = blocks.filter(b => b.type !== 'init');
    const sortedBlocks = [...initBlocks, ...normalBlocks];

    const { text: pyText, indexed } = buildMirror(sortedBlocks, rpyUri);

    const cd = await getCacheDir();
    if (!cd) {return;}
    const pyUri = rpyToPyUri(rpyUri, cd);

    await vscode.workspace.fs.createDirectory(pyUri.with({ path: pyUri.path.replace(/\/[^/]+$/, '') }));

    if (rebuildVersion.get(key) !== v) {return;}
    await vscode.workspace.fs.writeFile(pyUri, Buffer.from(pyText, 'utf8'));

    // save index and update store index
    fileIndex.set(key, indexed);
    removeFileFromStoreIndex(rpyUri.fsPath);
    addIndexedToStoreIndex(indexed);

    // invalidate cached doc so next ensurePyDocumentCached re-opens file
    invalidatePyDocumentCache(pyUri);
}

// find block by rpy line
function findBlockAt(blocks: IndexedBlock[], line: number): IndexedBlock | undefined {
    return blocks.find(b => line >= b.startLine && line < b.startLine + b.lineMap.length);
}

// ----------------- NEW: identifier helpers ----------------- //

// 获取光标下的标识符（只匹配 [A-Za-z0-9_]），返回字符串或 null
function getIdentifierAtPosition(doc: vscode.TextDocument, pos: vscode.Position): string | null {
    const wordRange = doc.getWordRangeAtPosition(pos, /[A-Za-z0-9_]+/);
    if (!wordRange) {return null;}
    return doc.getText(wordRange);
}

// 在单个 block.code 中寻找 identifier 的“最佳” py 位置
// 优先顺序： def identifier(...): | class identifier | identifier = ... | 首次出现 identifier
function findIdentifierPyPosInBlock(identifier: string, block: IndexedBlock): vscode.Position | null {
    if (!identifier) {return null;}
    const lines = block.code.split('\n');

    // patterns
    const defRegex = new RegExp(`^\\s*def\\s+${identifier}\\b`);
    const classRegex = new RegExp(`^\\s*class\\s+${identifier}\\b`);
    const assignRegex = new RegExp(`^\\s*${identifier}\\s*=`);
    const wordRegex = new RegExp(`\\b${identifier}\\b`);

    // 1) def
    for (let i = 0; i < lines.length; i++) {
        if (defRegex.test(lines[i])) {
            const entry = block.lineMap[i];
            if (!entry) {continue;}
            const col = Math.max(0, lines[i].indexOf(identifier) - (entry.rpyColBase ?? 0));
            return new vscode.Position(block.pyLineStart + entry.pyLine, col);
        }
    }
    // 2) class
    for (let i = 0; i < lines.length; i++) {
        if (classRegex.test(lines[i])) {
            const entry = block.lineMap[i];
            if (!entry) {continue;}
            const col = Math.max(0, lines[i].indexOf(identifier) - (entry.rpyColBase ?? 0));
            return new vscode.Position(block.pyLineStart + entry.pyLine, col);
        }
    }
    // 3) assignment
    for (let i = 0; i < lines.length; i++) {
        if (assignRegex.test(lines[i])) {
            const entry = block.lineMap[i];
            if (!entry) {continue;}
            const col = Math.max(0, lines[i].indexOf(identifier) - (entry.rpyColBase ?? 0));
            return new vscode.Position(block.pyLineStart + entry.pyLine, col);
        }
    }
    // 4) first occurrence
    for (let i = 0; i < lines.length; i++) {
        if (wordRegex.test(lines[i])) {
            const entry = block.lineMap[i];
            if (!entry) {continue;}
            const col = Math.max(0, lines[i].indexOf(identifier) - (entry.rpyColBase ?? 0));
            return new vscode.Position(block.pyLineStart + entry.pyLine, col);
        }
    }

    return null;
}

// ----------------- activate -----------------
export async function activate(ctx: vscode.ExtensionContext) {
    const cd = await getCacheDir();
    if (!cd) {return;}

    // initial indexing
    let files = await vscode.workspace.findFiles('**/*.rpy');
    files = sortRpyFiles(files);
    for (const f of files) {
        try { await rebuildFile(f); } catch (e) { console.error('initial rebuildFile failed', f.toString(), e); }
    }

    // Hover provider
    ctx.subscriptions.push(vscode.languages.registerHoverProvider('renpy', {
        async provideHover(doc, pos) {
            const blocks = fileIndex.get(doc.uri.toString());
            if (!blocks) {return null;}
            const block = findBlockAt(blocks, pos.line);
            if (!block) {return null;}

            // get identifier under cursor
            const identifier = getIdentifierAtPosition(doc, pos);

            const storeBlocks = storeIndex.get(block.store ?? 'store') ?? [];

            // if we have an identifier, try to query python hover at identifier positions inside each block
            if (identifier) {
                for (const b of storeBlocks) {
                    const pyUri = rpyToPyUri(vscode.Uri.file(b.filePath), cd);
                    // ensure doc open so python can analyze
                    try { await ensurePyDocumentCached(pyUri); } catch { continue; }

                    // find best place for identifier in this block
                    const pyPos = findIdentifierPyPosInBlock(identifier, b);
                    if (!pyPos) {continue;}

                    const hoverRes = await vscode.commands.executeCommand<vscode.Hover[]>(
                        'vscode.executeHoverProvider',
                        pyUri,
                        pyPos
                    );
                    if (hoverRes && hoverRes.length) {
                        const h = hoverRes[0];
                        if (!h.range) {return new vscode.Hover(h.contents);}
                        const startRpy = mapPyToAnyRpy(h.range.start, storeBlocks);
                        const endRpy = mapPyToAnyRpy(h.range.end, storeBlocks);
                        if (startRpy && endRpy) {return new vscode.Hover(h.contents, new vscode.Range(startRpy, endRpy));}
                        // fallback: map with current block
                        const startFb = mapPyToRpy(h.range.start, b);
                        const endFb = mapPyToRpy(h.range.end, b);
                        if (startFb && endFb) {return new vscode.Hover(h.contents, new vscode.Range(startFb, endFb));}
                        return new vscode.Hover(h.contents);
                    }
                }
                // 如果 identifier 搜索都没命中，退回到按位置映射
            }

            // fallback: try mapping exact rpy pos into each block's corresponding py pos and query
            for (const b of storeBlocks) {
                const pyUri = rpyToPyUri(vscode.Uri.file(b.filePath), cd);
                try { await ensurePyDocumentCached(pyUri); } catch { continue; }
                const pyPos = mapRpyToPy(pos, b);
                const hoverRes = await vscode.commands.executeCommand<vscode.Hover[]>(
                    'vscode.executeHoverProvider',
                    pyUri,
                    pyPos
                );
                if (hoverRes && hoverRes.length) {
                    const h = hoverRes[0];
                    if (!h.range) {return new vscode.Hover(h.contents);}
                    const startRpy = mapPyToAnyRpy(h.range.start, storeBlocks);
                    const endRpy = mapPyToAnyRpy(h.range.end, storeBlocks);
                    if (startRpy && endRpy) {return new vscode.Hover(h.contents, new vscode.Range(startRpy, endRpy));}
                    const startFb = mapPyToRpy(h.range.start, b);
                    const endFb = mapPyToRpy(h.range.end, b);
                    if (startFb && endFb) {return new vscode.Hover(h.contents, new vscode.Range(startFb, endFb));}
                    return new vscode.Hover(h.contents);
                }
            }

            return null;
        }
    }));

    // Definition provider (similar strategy)
    ctx.subscriptions.push(vscode.languages.registerDefinitionProvider('renpy', {
        async provideDefinition(doc, pos) {
            const blocks = fileIndex.get(doc.uri.toString());
            if (!blocks) {return null;}
            const block = findBlockAt(blocks, pos.line);
            if (!block) {return null;}

            const identifier = getIdentifierAtPosition(doc, pos);
            const storeBlocks = storeIndex.get(block.store ?? 'store') ?? [];

            if (identifier) {
                for (const b of storeBlocks) {
                    const pyUri = rpyToPyUri(vscode.Uri.file(b.filePath), cd);
                    try { await ensurePyDocumentCached(pyUri); } catch { continue; }
                    const pyPos = findIdentifierPyPosInBlock(identifier, b);
                    if (!pyPos) {continue;}
                    const defs = await vscode.commands.executeCommand<vscode.Location[]>(
                        'vscode.executeDefinitionProvider',
                        pyUri,
                        pyPos
                    );
                    if (defs && defs.length) {
                        const first = defs[0];
                        const mapped = mapPyToAnyRpy(first.range.start, storeBlocks);
                        if (mapped) {return new vscode.Location(vscode.Uri.file(b.filePath), mapped);}
                        const fallback = mapPyToRpy(first.range.start, b);
                        if (fallback) {return new vscode.Location(vscode.Uri.file(b.filePath), fallback);}
                    }
                }
            }

            // fallback: map current pos into each block
            for (const b of storeBlocks) {
                const pyUri = rpyToPyUri(vscode.Uri.file(b.filePath), cd);
                try { await ensurePyDocumentCached(pyUri); } catch { continue; }
                const pyPos = mapRpyToPy(pos, b);
                const defs = await vscode.commands.executeCommand<vscode.Location[]>(
                    'vscode.executeDefinitionProvider',
                    pyUri,
                    pyPos
                );
                if (defs && defs.length) {
                    const first = defs[0];
                    const mapped = mapPyToAnyRpy(first.range.start, storeBlocks);
                    if (mapped) {return new vscode.Location(vscode.Uri.file(b.filePath), mapped);}
                    const fallback = mapPyToRpy(first.range.start, b);
                    if (fallback) {return new vscode.Location(vscode.Uri.file(b.filePath), fallback);}
                }
            }

            return null;
        }
    }));

    // incremental update
    ctx.subscriptions.push(vscode.workspace.onDidChangeTextDocument(e => {
        if (e.document.languageId === 'renpy') {scheduleRebuild(e.document.uri);}
    }));

    ctx.subscriptions.push(vscode.workspace.onDidDeleteFiles(e => {
        for (const f of e.files) {
            const key = f.toString();
            fileIndex.delete(key);
            removeFileFromStoreIndex(f.fsPath);
            const cdLocal = cacheDir;
            if (cdLocal) {
                const pyUri = rpyToPyUri(f, cdLocal);
                invalidatePyDocumentCache(pyUri);
            }
        }
    }));

    ctx.subscriptions.push(vscode.workspace.onDidRenameFiles(e => {
        for (const f of e.files) {
            const oldKey = f.oldUri.toString();
            const data = fileIndex.get(oldKey);
            if (data) {
                fileIndex.delete(oldKey);
                fileIndex.set(f.newUri.toString(), data);
            }
        }
    }));
}

export function deactivate() {}
